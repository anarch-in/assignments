# Assignment 1: CSC633 Operating Systems

-------------------------------------------------------------------------------

## Question 1: Discuss all the main purpose of an operating system?

An operating system is a program that acts as an interface between the computer user and computer hardware. It provides an
environment that allows a user to execute application programs and manages the allocation of computer
hardware resources between users and processes. The core purposes of an operating system include:

__ Resource Manager__

* resources include cpu, memory, input/output devices
* operating system is responsible for the allocation of these resources to different users and processes.
	  
__Process Management__

* manages which process the cpu is allocated and for how long (achieved through scheduling)

__Memory Management__

* concerned with RAM
* before any program can be executed by the cpu, it must first be loaded into main memory (RAM)
* because main memory is finite, which process is loaded into memory or swapped out of memory is 
  decided by the operating system.
	  
__I/O Management__

* operating system allocates and manages all i/o devices i.e  which process or user can access
  the i/o device and at what time is the responsibility of the operating system.
	  
__Storage Management__

* concerned with the hard disk (secondary memory)
* operating system is responsible for how data is stored and accessed in secondary memory.

__Security/Protection__

* responsible for managing user accounts, storage of passwords and authenticating users at login.
* provides process level security i.e in cases where multiple processes are running, it ensures
  that each process is not interfered by another.

## Question 2: Describe what are interrupts? How does an interrupt differ from a trap? Can traps be generated intentionally by a user program? If so, for what purpose? 

Modern operating systems are interrupt driven. That is, instead of the checking on each hardware 
device to see if there is an event to be taken care of (polling), the operating system lays back and does its own 
thing until the hardware/software signals to the operating system via an interrupt that they need its attention. 
 
There are of two types interrupts, hardware generated interrupts and software generated interrupts. A hardware generated
interrupt provides a way for the hardware(mostly I/O devices) to alert the operating system that an event has taken 
place and it needs to be handled. For example, when a key is pressed on your keyboard and interrupt is generated, when 
you move your mouse or click on an icon an interrupt is generated. This interrupt comes in the form of a signal, the 
processor recieves this signal and notifies the operating system that its attention is needed. The operating system
then pre-empts whatever process is currently running(i.e puts in a blocked state) attends to the interrupt via an interrupt 
handler - once finished, execution of the pre-empted process resumes.

A trap(or exception) is a software generated interrupt. It has a similar function to the hardware interrupt but are 
generated by application programs(software). These signals are generated when special events or errors occur during 
the execution of a program. The program can not handle it itself and thus alerts the operating system for assistance.
For example when the program encounters a division by zero error or when the program tries to access a portion in
memory it is not assigned to (memory segmentation). The difference between the two terminologies is blurred in most 
textbooks, with interrupts being the preferred term to describe both terminologies, however, when staking a difference
between the two, interrupts are hardware generated and traps are software generated.

There are two common occassions where traps are intentionally generated. The first being for debugging purposes, such as 
catching arithmetic errors and the second is when a program requires some of its instructions to be executed in kernel mode.
The request is sent as a system call which is implemented as a trap. Refer to diagram below.
 
 [insert diagram]
 
## Question 3: Describe some of the challenges of designing operating systems for mobile devices compared with designing operating systems for traditional PCs. 

The defining feature of a mobile device is its portability. It must be small enough to take around with 
you and still provide the same experience as a traditional PC for laptops or Hi-Fi Stereos for ipods
and mp3 players. To achieve this portability, alot of trade-offs will have to be made interms of the size of the 
components that power and drive the device. And this reduction in size poses challenges when designing operating 
systems to control and manage these devices. Below is a list of these challenges:

1. __Battery issues__
	Because of the mobility of the device, it will not always be connected to a power source. Thus these devices 
	rely on batteries and it is important that the operating system is designed in such a way that it manages the 
	apps and the devices so that battery is not depleted unnecessarily. Some mobile operating systems come pre-
	installed with utilities that inform you which apps are draining your battery. Also you must ensure that the 
	operating system is able to resume a session with an app if it is interrupted. Battery is consumed when the 
	screen of your device is on, and the longer an app takes to complete a task, the more battery is depleted, thus
	if a session with an app is interrupted and cannot resume from where you left off, then starting your task 
	all over again is an example of unneccessary consumption of baterry.
	
2. __Screen Size and orientation issues__
	A mobile device has significantly less real estate to work with when it comes to screen size. Therefore alot of 
	consideration has to be taken into account for interface design. Navigation has to be planned and designed
	so that it is intuitive to the user. If a task has multiple steps, it must be split into distinct screens. The 
	user must also be given the correct cues(can be visual or audio) so that he/she is guided to complete the task.
	
	Changing the screen orientation when the user turns the device has challenges of its own. Each element in the 
	layout or view would have to re-organized itself according to the orientation of the screen. Some elements that 
	were accessable in the horizontal orientation would be hidden in the verticle orientation. Which elements are 
	not important enough to be hidden are all considerations that have to be taken care of.

3. __Security__
	Latest phones are incorparating hardware for biometric authentication(fingerprint sensors). Some are using 
	existing hardware on the mobile device(facial recognition via phone's camera).
	In this case the operating system has to keep up with these advances, ingenius ways must be introduce to distinguish
	between a real face and an image programmably. If it can not make this distinction, then people will be gaining 
	unauthorised access using photos. Also mobile devices are more susceptable to being stolen because of its portability, 
	thus the developer must incorparate services that allow remote wiping of data, or services to track a stolen phone.
	
	
## Question 4: Discuss how system calls function?

A system call is when an application program requests a service from the operating system. Its function is to provide an interface
that allows the application program to request for services provided by the operating system.

To better understand how a system call functions, we must first understand why is it required in the first place. Why
does the application have to go through the extra step of requesting for the service? Why isn't it given direct access?

There are two modes that a program can run in, _user mode_ and _kernal mode_. If a program is running in _user mode,_ then 
it does not have access to the hardware resources. If a program is running in _kernal mode_ , it has direct access
to hardware resources. The problem with running a program in kernel mode is that if it crashes, not only will the 
entire system come to a halt, it could cause irreversable or serious problems.
Thus executing all application programs in user mode provides a "sandbox" that shields the kernal and system from this.
Only when a program requires system resources, it must first request permission from the operating system. This request is put forth 
in the form of a system call. The system call allows the application program to communicate to the operating system that it requires 
access to certain hardware resources/services. The operating system then swtiches the program to kernel mode via a 
mode bit. When the process is done, another system call is made to the operating system to perform a switch back to user 
mode. Note everytime a switch is made, a system call precedes this switch.

Below is a diagram illustrating how the system calls function

System calls differ from one operating system to another, but the underlying concept remains the same.



## Question 5: Discuss three common ways of establishing relationship between the user and kernel thread?  

In an operating system, threads are either implemented as __user level threads__ or __kernel level threads__. User level threads 
are managed by the user and the operating system manages the latter. Some operating systems provide the facilities to implement 
both thus creating a multithreading system. In this type of system, multiple threads within the same application can run in 
parallel on multiple processors(Operating System - Multi-Threading - Tutorialspoint, 2020). Thus in order for the two types of 
threads to work in tandem, a relationship must be established between the two and there are three models that accomplish this:
	* many-to-many
	* many-to-one
	* one-to-one

__Many-to-One Model__ In this model, many user-level threads is mapped to one kernal thread. The threads are managed by a thread 
library in the user space and when a single thread makes a blocking system call, the entire process will be blocked. 

__Drawbacks:__
Only one thread can access the kernel at a time - therefore multiple threads are unable to run in parallel despite the system
having multiple cores. Because of this, only a handful of systems continue to use this model.


__One-to-One Mode__ Each user thread is mapped to a kernel thread. This model supports both concurrency and parallelism i.e while a 
thread makes a blocking system call, it is possible for another thread to be run. Multiple threads are also able to run on 
systems with multiple processors.

__Drawbacks:__
For systems that implement this model, the number of threads that can be supported by the system is limited. The reason for this 
is that for each user thread that is created, a corresponding kernel thread must be created. This inturn creates alot of overhead
which could affect the performance of an application.


__Many-to-Many Model__ Here many user threads are mapped to an equal or lesser number of kernal threads. This model does not inherit 
any of the drawbacks inherent to the above models. There is no restrictions to the number of threads that can be created and the entire 
process is not block if a thread makes a system call. Kernel thread can also run in parallel on a multiprocessor system. The 
many-to-many model also has a variation model called the _two level model_. This model used to be implemented on older Solaris
operating systems.

## Question 6:

### Which algorithm would give the minimum average waiting time?

Shortest Job First (SJF)



## Question 7: What are the possible states that a thread can be in? 

A thread can be in any one of the following states (Tanenbaum and Bos, 2013):
	* __running__ in a running state, the thread is active and is using cpu resources
	* __blocked__ in a blocked state, the thread is waiting for an event, eg: I/O operation
	* __ready__ Here the thread is scheduled to run and waiting on the cpu 
	* __terminated__ the thread has either reached the natural completion of its task or is aborted due to an error. In this state the 
	             thread is no longer eligible for execution.

## Question 8: What are "zombie" threads? When does it get finally cleaned up?

The term "zombie" is used to describe the state of a process or thread. And this state can be better understood in the context of 
a process. 

When a process is created, it is possible for that process to create another process. When this happens, it is called 
__process spawning__. The newly created process is called the child process and the process that spawned  the child process is called
its parent. On a Unix system, this is achieved using the _fork()_ system call. After the child process is created, it is given a 
unique ID that identifies it in the processes table. Now, when a  child process is killed,  all of the memory and resources 
associated with it is deallocated so that it can be used by other newly created processes. However the processes ID still remain in
the process table and the process descriptor(information about the process attributes, identification details and resource allocation 
entries that the process holds) remains in memory. It is at this instance that the process is in a zombie state - it is already killed 
yet life of its exitance still exists in memory and in the processes table. The process remains in this state until the parent process 
is notified via a SIGCHLD signal. It then executes the wait() system call to which the zombie process is then reaped or removed 
completely.

There are times when the parent process is not correctly programmed and it does not execute the wait() system call. In this 
case the zombie process continues to exist in memory unless the parent process is killed. When this happens,
the init process becomes the new parent of the zombie processes.

The init process periodically executes the wait() system call,and inturn, cleans all the zombie processes that it has inherited.

## Question 9: Which function is used to put a thread to sleep?
  
The sleep system call places a thread into an inactive state for a period of time.

__Windows OS__ On Windows, the Sleep() function takes a single parameter which is the number of milliseconds to sleep.

__Unix__ On Unix or Posix operating systems, the sleep() function is called providing the number of seconds to sleep. The 
data type of the argument must be an unsigned integer.

## Question 10: As described in Section 4.7.2, Linux does not distinguish between processes and threads. Instead, Linux treats both in the same way, allowing a task to be more akin to a process or a thread depending on the set of flags passed to the clone() system call. However, other operating systems, such as Windows, treat processes and threads differently. Typically, such systems use a notation in which the data structure for a process contains pointers to the separate threads belonging to the process. Contrast these two approaches for modeling processes and threads within the kernel. 


## Question 11: How does multiprogramming increase the utilization of resources

When a process is executed by the cpu, evantually there comes a time when it needs to carry out some I/O
operations. Since i/o operations do not require cpu resources, in a non-multiprogramming system, the cpu is
left idle during this period. 

However, this is not the case in a multiprogramming system, while I/O operations are being performed, the cpu
fetches and executes the next process waiting in memory. Once the process waiting for I/O operations is ready, 
the currently executed process is put into a ready state and moved back to main memory.
Execution then resumes for the former process. This "process " continues as long as there is a process 
waiting in memory to be executed.

Should main memory become full(i.e the quota reserved in main memory to hold processes), a job pool is created in
secondary memory. A job pool is a collection of processes that reside on the hard disk, waiting to be loaded into
main memory as soon as space is available. This ensures the full utilization of main memory. Virtual memory also 
plays a role in memory utilization.


## Question 12: Discuss the disadvantages of the Linux Systems

__Steep Learning Curve__ Linux is not as easy to learn as the Windows or Mac operating systems. It has a steep learning 
curve and requires a broader base of computing knowledgethan other operating systems. Transition from a 
Windows operating system to Linux may require you to unlearn things. The file structure isn't the same i.e there is 
no "program files" directory or C or D drive. Setting permissions to files and directories aren't the same, and 
installation of software aren't always cut and dry. Some programs require dependencies before the actual program can be installed and 
mostly these dependencies need to be installed via the terminal(or commandline). Which would require abit of effort on the user's
part to learning basic commands. While it is possible to gain understanding of the 
operating system through practice, it does require a technical threshold to be reached before one is proficient.

__Portability__ not all hardware and software are compatiable with linux. Common problems users face is the availability of 
drivers. User my buy a new laptop which comes with the latest hardware eg: latest graphics card or a sub-woofer. In 
order for these components to play nice with the operating system, they require drivers - and drivers for new hardware take 
alot of time to surface. Most of them will have to be installed manually and also require a hunt for depedencies. Your favourite
software like microsoft office or PC games are not compatiable with linux. Although there are alternatives on with similar functions
available they make take a bit of time to get use to. Propriety business software may not support linux i.e software provided by the 
organization you work may require the extra effort of  dual booting with Windows or using a virtual machine in order to run.

__Technical Issues__ because linux is open source, every now and then you are likely to run into some technical issues. There are 
frequent security patches and kernal updates and some of these updates do not work well your existing software. 
Thus you might frequently find yourself doing one of two things, either wait for a patch of that software to be released so that it 
works with the new kernel, or you would have to revert back to the old kernal. 

__Too Many Variants__ There is a plethora of flavours to choose from when it comes to linux and each flavour is known as a 
distribution. Distributions are mostly released targeting a specific audiance. For example it you are a journalist and
a concerned about privacy and the anonymity of your sources, then you might prefer the tails operating system; if you 
are a penetration tester or a computer enthusiast interested in computer security then you have the option of Kali linux,
Black Arch and Parrot OS. 
Each of these distributions have some utilities that make them better suited for a job then others and if you are a 
penetration tester who is running Kali Linux and encounter a job that is better suited for Black Arch, then you would 
find yourself doing alot of "distro hopping". Thus to mitigate this, alot of developers, tech enthusiasts and penetration
testers use virtual machines that allow them to host different distros.



-------------------------------------------------------------------------------------------------------------------------

# Assignment 2

* Compare and contrast Linux and Windows 7 under the following topics:
    • History of both operating systems
    • Current popularity and usage
    • Process Management
    • Process Scheduling
    • Process synchronization
    • Inter-process communication
    • Memory Management
    • File Systems
    • General comments/findings


## History of both operating systems

### Linux

In order for a computer to work you need an operating system. In order for an 
operating system to work you need a kernel. Thus our history of the Linux Operating
System starts from the kernel. 

The Linux kernal was written by Linus Tovalds in 1991 while still a student at the 
University of Helsinki. This endeavour stemmed from the short commings of the Minix
Operating System.

The Minix operating system was made available to almost all universities in Europe. It 
was a non-free Unix-like system created by Andrew S. Tanenbaum to exemplify and help students 
grasp the fundamental principles he had laid out in his book,  __Operating Systems: Design and 
Implementation__ (1987) which was the go to text for operating systems at that time. However, 
because it was not free and because it did not support terminal emulation, Linus Torvalds 
setout to create his own terminal emulation[1]. This initiative then grew into an obsession 
of creating an operating system that would replace Minix, was free and addressed some of the 
limitations that Minix had.


By August of '91, a usable version of the kernal had come into shape and for the first time 
Linus announced to the Minix community via the _comp.os.minix newsgroup_ his intensions for the 
new kernal and solicited suggestions on what features they liked about the Minix operating 
system and features they would like to see implemented[refer appendix 1].

The message aroused the curiosity of Ari Lemke, who was a teaching assistant at Helsinki 
University. He replied to Linus offering to create a sub-directory on the univeristy's ftp
site which would make the OS available for download for those interested once it was 
ready. It's important to point out that it was Ari Lemke who cemented the name Linux, for the 
operating system. Linus Torvalds thought it would be egotistacal to name the OS after himself 
and uploaded it under the name Freax on the ftp site. This was then changed by Ari to Linux when
it was finally made available for download.

Before it was made available to the public, the kernal had gone through a number of iterations.
However, what good is a kernal without an operating system. Linux is NOT an operating system. 
It is a kernel, and the job of the kernel is to allocate your PC's resources to the programs 
that you run. Thus the second step was to the operating system was to implement programs that 
would put the kernel to work and thanks to Richard Stallman's (the father of the Free Software 
Foundation) GNU Project, programs like the Bash Terminal or the GNU gcc C compiler were able 
to be implemented free of charge under the _copyleft GPL licensing._[2]

Now that the user is able to interact with the system via the Bash Terminal, the next logical 
step was to enable support for the graphical user interface via the X windowing system. X 
window system had its origins at MIT and was ported to Linux by Orest Zborowski. It uses a 
socket layer which was only tacked ontop of Linux and not integerated with other code. The
integration was then patched by Linus Torvolds. The underlying socket layer now only gave 
users gui windows to work with, it also laid the foundation for networking.

By March '94, the initial goal had manifested into a pre-determined conclusion, and in the
auditorium of the University of Helsinki Computer Sciences Department, a fully fledged 
operating system with networking capabilities was released.

"Tux " the penguine logo was suggested by Tove Tovalds, the wife of Linus Torvalds.


### Microsoft Windows

Microsoft was founded by Paul Allen and Bill Gates in April of 1975. It started off as 
a software based company where their first project was to create software for the Altair 8800
computer. The Altair 8800 came with the latest Intel 8080 processor but did not have any software.

Thus Bill and Paul set out to write software for the new computer. This was not the first time they 
had written software for hardware. They initial attempts were writing BASIC for the PDP-8 computer in 
their school. However this was quailed early since it did not have enough transistors to run the language
(Gates and Myhrvold, 1995). Thus when the Altaire 8800 was released with the latest Intel 8080 proceessor,
this opened up the oppotunity to test and monetized their unique skills. 

The Altaire 8800 was the first sucessful microcomputer developed by MITS (Micro Instrumentation and Telemetry Systems).
In the 1970's, computers were very expensive and their large sizes could fill rooms. Thus they were only available in 
Corporations and Universities or schools. So when the portable Altaire 8800 was released, it allowed consumers to 
finally have a computer at home that was affordable and could fit on a table. However, for the time being, there was only 
little you could do since it did not have any software and it came as a kit which required it to be assembled before it 
could be used (Altair 8800 Microcomputer, 2020).

[insert image: altaire 8800, pdp-8]

Seeing this oppotunity, Bill and Paul created Microsoft BASIC. A programming language that allowed programmers create 
software that provided a better user experience. Microsoft continued to build software for MITS until it(MITS) was 
eventually acquired. 

By 1977, other companies started to build PC's such as Apple, Commodore and Radio Shack. And Microsoft provided BASIC for 
the early PC's. Usage of their software ranged from \$50-100k, but this seemed a cheaper investment than creating their 
own programming language. Eventually Microsoft BASIC became the gold standard for software and manufacturers started 
advertising their PC's as Microsoft BASIC compatiable. At this time, BASIC was only sold to manufacturers because of fears 
of piracy.


In 1980, the leading computer manufacturer IBM, approached Bill Gates. Up until now, IBM had only manufactured mainframe computers
for corporations. However, in their meeting with Bill Gates, they had made known their intensions of moving into 
the manufacturing of not only personal computers but personal computers that came with an operating system. The meeting 
was closed with a one year deadline to create the operating system and Microsoft retaining ownership of the operating 
system despite it being pre-install on IBM computers. Ownership of the operating system source code was important to 
Microsoft as it allowed them to sell their operating system to other manufacturers and not only IBM.

While IBM computers came out with a command-line operating system(MS-DOS), Steve Jobs, co-founder of Apple Computers was 
working on a computer called Lisa. Lisa came with a GUI based operating system, a keyboard and the first mouse but 
was missing application software. Steve Wozniak, the leading developer of Lisa had developed a derivative of the original 
BASIC programming language similar to how Bill Gates and Paul Allen wrote Microsoft BASIC. This was to be the programming
language used to create applications on the Lisa. However, Steve Wozniack's BASIC did not support floating point numbers 
and Bill Gates and Paul Allen's did, so Steve Jobs approached Bill Gates to use their version of BASIC. Eventually 
Microsoft started creating application software for the Macintosh.


The Alto was the first GUI based computer. It was developed by Xerox but was never sold commercially. Seeing the 
success of the GUI based Macintosh, Bill Gates was introduced to Charles Simonyi, an employee at Xerox. He asked for 
a tour of the Xerox facility and soon after hired Charles Simonyi to work for Microsoft. By 1985, Microsoft's GUI
based operating system, Windows 1.0, was released. This did not sit well with Steve Jobs leading to controversey's that
Bill Gates had stolen his ideas, regardless, Microsoft continued to dominate the software industry and by now they 
were creating operating systems for IBM, application software for the Macintosh and releasing their GUI operating system Windows
with applications such as Microsoft Word and Excel. 1985 was Microsoft inception into both operating systems and application 
software, this laid the foundations for the other versions of the Windows operating system and other well known applications
like the office suite and internet explorer know known as Microsoft Edge.

[insert image: evolution of Windows operating system]

### Windows 7


## Popularity and Usage

[insert image: world desktop market shares]

__Windows__   referencing the above statistics, it is clear that Linux is the ugly sister and Windows is the more popular out 
		  of the two[in the desktop market]. Even going back a minus 5 and minus 10 years back, statistics shows that Windows have consistently dominated the Desktop 
		  market.  
		  
		 [insert image: world desktop market shares -decade]
		 
		 Usage include multi media, PC gaming, web browsing, networking, word processing, spreadsheets and databasing, web development, programming, virtualization and 
		 remote desktop usage. 

__Linux__ is more popular amongst power users, enthusiasts, and those who believe that software should be free. Usage of Linux includes (more recently) PC gaming, networking, system 
      administration, penetrations testing, web development, programming, security and privacy, debugging and testing. 
	  
	  

The Linux operating system is free, contains free application software and has more than 270 distributions (DistroWatch.com:Use Linux, BSD., 2020) that appeal to different 
audiances worldwide. Yet, its usage is at an almost non-existant 1.7%. Windows has a 77% usage and second is Apple's OSX at 18%.
The popularity of Microsoft's OS is due to how it is deployed. Go to any computer vendor(except Apple), and almost 99% of the 
computers sold, comes pre-installed with Windows. This is also the reason why Apple is the second most used operating system. They too deploy their own computers with 
OSX but are still being dominated becauase of the competition against majority of computer manufacturers that ship with Windows.

Regardless, Linux has found appeal mostly amongst the minority.Its usage is predominantly centered around system administration, system development/creation and 
system management. And the reason for this is because of its system utilites and its open source licensing. This is what separates it from other main stream operating systems.
With Windows, your computer experience is decided by a handful of developers, and once they have made a decision on a feature, it is set in stone. You do not like it, 
there really is not much that can be done. For Linux, almost all facets of the operating system is customizable thanks to open source licensing. And this philosophy has resonated 
mostly with those who are system builders by nature. When using Linux, you are either creating, controlling or managing and linux provides the tools and freedom to do 
this.


## Memory Management

### Linux

The memory management of Linux is centered around the management of two components,
physical memory and virtual memory. 


#### Physical Memory

__Physical memory__ refers to Random Access Memory which is abstracted as pages, groups 
of pages or small blocks of RAM. For 32bit achitectures, the Linux kernal assigns 
4GB of virtual memory to each process. 3GB of virtual address space is used for 
itself, and 1G is for its page tables and kernel data (Tanenbaum and Bos, n.d.). 
The physical memory that is mapped to this 1GB virtual address space is then further divided
into zones as will be described below.

  ----> [insert image: kernal zones (https://unix.stackexchange.com/questions/5143/zone-normal-and-its-association-with-kernel-user-pages)]

To keep up with advances in hardware technology and at the same time continue to support legacy 
hardware, the physical memory had to be partioned into four zones. In the past, computers had buses
and older hardware that could only handle 24bit addresses. This meant that they could 
only access 2^24 (16MB) of RAM and could not handle addresses greater than 24bits.

An example of this were the ISA buses. These buses were integrated onto the motherboard and allowed you to connect
expansion cards such as network or video cards. They were controlled by a Direct Memory Access processor
(DMA)which could only access 16MB of RAM (ISA (Industry Standard Architecture) Definition, 2020).

--> [insert: image of ISA bus]

The second example were the 32bit processors. They contained registers that could only handle 32bit 
addresses. Thus if you installed a 16GB RAM, only 4GB (2^32) would be accessable by the CPU. Address
space larger than 4GB were too large for the registers to accomodate.

Thus to mitigate these hardware constraints, memory was divided into zones:

	• ZONE_DMA
	• ZONE_DMA32 
	• ZONE_NORMAL
	• ZONE_HIGHMEM

Based on the address space, Zone_DMA catered for devices which could handle addresses less than 24bits (16MB). For example the
DMA devices such as ISA buses (above). _Zone_DMA32_ catered for devices that supported 64bit addresses but could only access addresses
upto 32bits in length (4GB). _Zone_NORMAL_ comprises of an addresses space between 16MB and below 896MB. The addresses between this space can 
be mapped/accessed by the kernel directly (Love, 2015). _ZONE_HIGHMEM_ is the address space above 896MB. This space can not be directly accessed by the 
kernel. For 64bit achitectures, this is usually empty (Bovet and Cesati, 2007).




## What is DMA
(Direct Memory Access) chip that can control the flow of bits between memory
and some controller without constant CPU intervention. The CPU sets up the
DMA chip, telling it how many bytes to transfer, the device and memory addresses
involved, and the direction, and lets it go. When the DMA chip is done, it causes
an interrupt, which is handled as described above.





and virtual memory is memory mapped into the address space of running processes.


























------------------------------------------------------------------------------------------------------------------------------------------------------------

[1]: Linus needed the terminal emulation program to connect his residential computer to the 
     univeristy computer to complete work or go online. Since he was running Minix, and Minix 
	 did not support terminal emulation, he set out to write his own.
	 
[2]: It is a series of software licenses that guarantees the end user the freedom to run, study, 
     share and modify the software. The licenses were originally written by Richard Stallman. 

 
## References

[Differences between Linux and Windows](https://techdifferences.com/difference-between-linux-and-windows-operating-system.html)
[1]:https://www.geeksforgeeks.org/difference-between-operating-system-and-kernel/



## More Clarification

* WHy memory memory segmentation and not base-limit register?
* Linus Torvalds???
* information on GNU ---> [2]:https://en.wikipedia.org/wiki/GNU [needs citation]
* 32bit and 64bit address space?? lacks info on comparison.
* What is GPL?
 It is a series of software licenses that guarantees the end user the freedom to 
run, study, share and modify the software. The licenses were originally written 
by Richard Stallman. 

* The GPL is a _copyleft_ (as oppose to copyright)license, meaning that the authors work
  can be used, shared and modified however, any derivative of the software must 
  be distributed under the same or equivalent license terms.
	* _copyright_ whatever content the author created can not be used, published or 
	  modified without the consent of the author.

* June 2007 saw the release of version 3 of the GPL licensing 

reference: (https://en.wikipedia.org/wiki/GNU_General_Public_License)
  
  
## Bibliography

Torvalds, L. and Diamond, D., 2002. Just For Fun. New York [etc.]: HarperBusiness.

Gates, B. and Myhrvold, N., 1995. The Road Ahead. London: Viking.

Strother, R., 2008. Bill Gates. Edina, Minn.: ABDO Pub.

Bovet, D. and Cesati, M., 2007. Understanding The Linux Kernel. Sebastopol: O'Reilly Media, Inc.

Love, R., 2015. Linux Kernel Development. Upper Saddle River: Addison-Wesley.

Tanenbaum, A. and Bos, H., n.d. Modern Operating Systems.

National Museum of American History. 2020. Altair 8800 Microcomputer. [online] Available at: <https://americanhistory.si.edu/collections/search/object/nmah_334396> [Accessed 10 April 2020].

En.wikipedia.org. 2020. MINIX. [online] Available at: <https://en.wikipedia.org/wiki/MINIX> [Accessed 11 April 2020].

StatCounter Global Stats. 2020. Desktop Operating System Market Share Worldwide | Statcounter Global Stats. [online] Available at: <https://gs.statcounter.com/os-market-share/desktop/worldwide/2019> [Accessed 12 April 2020].
  
Distrowatch.com. 2020. Distrowatch.Com: Use Linux, BSD.. [online] Available at: <https://distrowatch.com/dwres.php?resource=popularity> [Accessed 12 April 2020].
  
Techterms.com. 2020. ISA (Industry Standard Architecture) Definition. [online] Available at: <https://techterms.com/definition/isa> [Accessed 14 April 2020].



------------------------------------------------------------------------------- 



 

